## Objetivo 
In RSA d is a lot bigger than e, why don't we use d to encrypt instead of e? Connect with `nc jupiter.challenges.picoctf.org 19566`.
## Solución  
```bash
└─$ python3                 
Python 3.12.6 (main, Sep  7 2024, 14:20:15) [GCC 14.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from Crypto.Util.number import long_to_bytes
>>> c = 61408184358056090839443828291422172311973162274349599139497386794884768356286745698570039209550551290975131353291257034227436570662369795162472020575691034634869971883459302884620595569138520369839172438442272553559199135753659678173094222531405921077070711529293362117710347294277371169331005103794973528797
>>> n = 74222589656940546302560327947357772951770914786302225040310326091582214707056815314225450876155114107946530299730965280242804086847498040100140013414223298269922329867184478568370588532067757677194188917491285244653313595158283317288854023846415329454027251374461928504349089360431905317090050847406875397931
>>> d = 39390510564384227855247429182554140425035387448042749731098973889426141106949404053345063199773426061438397704425632900683964309392294876676121424638907791594761700097955351726451154867597898568618100476318003816152738657316020150695149084179907296117366760831935816548055840443671966359012284666423915474369
>>> e =65537
>>> m = pow(c,e,n)
>>> m
180638594769037903267909311328535969949661653321164402927482237
>>> long_to_bytes(m)
b'picoCTF{bad_1d3a5_2438125}'
```
## Notas Adicionales 
Primero, abrí una terminal en Kali Linux y me conecte al servidor con netcat, despues inicié una sesión de Python 3. Utilicé la biblioteca Crypto.Util.number para convertir un número largo en bytes. Luego, trabajé con un reto de criptografía RSA, en el cual tenía la clave privada y pública, además de un valor cifrado. Los pasos fueron los siguientes:
Definí el valor cifrado c, el módulo n y el exponente privado d.
Realicé una operación de descifrado utilizando la fórmula RSA clásica m = pow(c, e, n), donde e es el exponente público. Esto me permitió calcular el mensaje cifrado m.
Finalmente, convertí el mensaje m a su representación en bytes con long_to_bytes(m), obteniendo la bandera del reto CTF: picoCTF{bad_1d3a5_2438125}.
### Referencias
